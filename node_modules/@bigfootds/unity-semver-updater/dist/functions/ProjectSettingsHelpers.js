"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectSettingsHelpers = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const constants_1 = require("../utils/constants");
const UnityProjectVersion_1 = require("../utils/UnityProjectVersion");
const RegexFromString_1 = require("./RegexFromString");
async function readTargetFile(targetFilePath) {
    let fileAsItWasRead = await promises_1.default.readFile(targetFilePath, { encoding: 'utf8' });
    return fileAsItWasRead;
}
class ProjectSettingsHelpers {
    /**
     * Parse a targeted `ProjectSettings.asset` file and retrieve its stored `bundleVersion` property.
     *
     * This property typically is used as the "Version" of a Unity project in that project's player settings.
     * @author BigfootDS
     *
     * @export
     * @async
     * @param {string} targetFilePath An absolute file path to a `ProjectSettings.asset` file for a Unity project.
     * @param {string} valueFormat A string that will get processed and turned into regex to find an existing project's semver version.
     * @returns {string} The semver value assigned to the bundleVersion property of the targeted `ProjectSettings.asset` file, in a helper format for multiple Unity-supported platforms.
     */
    static async getExistingBundleVersion(targetFilePath, valueFormat = `bundleVersion: ${constants_1.regexSemverWithQuadAndExtensions.source}`) {
        console.log("Will use this regex to find existing semver data in the target file:\n" + valueFormat);
        let fileAsItWasRead = await readTargetFile(targetFilePath);
        let regexResult = (0, RegexFromString_1.makeRegexpFromStringFormat)(valueFormat).exec(fileAsItWasRead) || "";
        if (regexResult == "") {
            console.log("Custom format for semver regex did not find anything. Falling back to 'default plus release label plus build label plus quad number' regex instead.");
            regexResult = constants_1.regexFindBundleVersionWithQuad.exec(fileAsItWasRead) || "";
        }
        if (regexResult == "") {
            return null;
        }
        let regexResultGroups = regexResult.groups;
        return new UnityProjectVersion_1.UnityProjectVersion(Number.parseInt((regexResultGroups === null || regexResultGroups === void 0 ? void 0 : regexResultGroups.major) || "0") || 0, Number.parseInt((regexResultGroups === null || regexResultGroups === void 0 ? void 0 : regexResultGroups.minor) || "0") || 0, Number.parseInt((regexResultGroups === null || regexResultGroups === void 0 ? void 0 : regexResultGroups.patch) || "0") || 0, Number.parseInt((regexResultGroups === null || regexResultGroups === void 0 ? void 0 : regexResultGroups.quad) || "0") || 0, (regexResultGroups === null || regexResultGroups === void 0 ? void 0 : regexResultGroups.releaseLabel) || "", (regexResultGroups === null || regexResultGroups === void 0 ? void 0 : regexResultGroups.buildLabel) || "", regexResult ? regexResult[0].toString() : "");
    }
    /**
     * Write a collection of version strings to the ProjectSettings asset file.
     * @author BigfootDS
     *
     * @export
     * @async
     * @param {string} targetFilePath Path to the `ProjectSettings.asset` file.
     * @param {PlayerSettingsVersionStrings} targetPropertyCollection Structured object of version strings and numbers, per whatever the supported Unity platforms need.
     * @param {string} searchFormat A string that will get processed and turned into regex to find an existing project's semver version.
     * @returns {boolean} True on a smooth, successful write. False if anything went wrong.
     */
    static async writeToProjectSettings(targetFilePath, targetPropertyCollection, searchFormat = constants_1.regexSemverWithQuadAndExtensions.source) {
        let success = false;
        let fileAsItWasRead = await readTargetFile(targetFilePath);
        let fileModified = fileAsItWasRead;
        let propertiesNotUpdated = [];
        let targetPropEntries = Object.entries(targetPropertyCollection);
        for (let index = 0; index < targetPropEntries.length; index++) {
            const targetProp = targetPropEntries[index];
            switch (targetProp[0]) {
                case "bundleVersion":
                case "switchReleaseVersion":
                case "switchDisplayVersion":
                case "ps4MasterVersion":
                case "ps4AppVersion":
                case "metroPackageVersion":
                case "XboxOneVersion":
                case "psp2MasterVersion":
                case "psp2AppVersion":
                case "supportedProperty":
                    let customFormatRegexp = (0, RegexFromString_1.makeRegexpFromStringFormat)(`${targetProp[0]}: ` + searchFormat);
                    // console.log(customFormatRegexp);
                    let tempFileModified = fileModified.replace(customFormatRegexp, `${targetProp[0]}: ${targetProp[1]}`);
                    if (fileModified != tempFileModified) {
                        fileModified = tempFileModified;
                        break;
                    }
                default:
                    propertiesNotUpdated.push(targetProp[0]);
                    break;
            }
        }
        if (propertiesNotUpdated.length > 0) {
            console.log("These properties were not found or did not have existing values found in a matching format, and thus were not updated:\n" + propertiesNotUpdated);
        }
        let result = await promises_1.default.writeFile(targetFilePath, fileModified);
        if (result === undefined) {
            success = true;
        }
        return success;
    }
}
exports.ProjectSettingsHelpers = ProjectSettingsHelpers;
